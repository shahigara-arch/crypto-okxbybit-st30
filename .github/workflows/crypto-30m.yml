name: Crypto ST 30m (OKX/Bybit)

on:
  schedule:
    - cron: "2,32 * * * *"   # every 30m +2 min UTC
  workflow_dispatch:

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas numpy requests

      - name: Write bot file
        shell: bash
        run: |
          cat > runner_bot.py << 'PY'
# runner_bot.py ‚Äî OKX/Bybit 30m ST+MACD with Hidden Strength
import os, time, html, requests, datetime as dt, sys, traceback
import numpy as np
import pandas as pd

TOP_N = 100
INTERVAL_MIN = 30
MIN_PRICE = 0.05
MIN_QVOL = 10_000_000.0
TIMEOUT = 20
RETRIES = 3
THROTTLE = 0.03
SRC = os.environ.get("EX_SOURCE", "okx").strip().lower()   # okx | bybit
TV_PREFIX = "OKX" if SRC == "okx" else "BYBIT"

ULTRA_MIN_RVOL = 2.0
ULTRA_MIN_ADX  = 20.0
ULTRA_BO_TOL   = 0.005
ULTRA_OB_MIN   = 0.55

S = requests.Session()
S.headers.update({"User-Agent": "Mozilla/5.0", "Accept": "application/json,text/plain,*/*"})

def log(*a): print(dt.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"), "-", *a, flush=True)

def get_json(url, params=None, retries=RETRIES):
    for i in range(retries):
        try:
            r = S.get(url, params=params, timeout=TIMEOUT)
            if r.status_code == 200:
                return r.json()
            log("HTTP", r.status_code, url, "Body:", (r.text or "")[:180])
            time.sleep(1+i)
        except Exception as e:
            log("GET err:", url, e)
            time.sleep(1+i)
    raise RuntimeError(f"GET failed: {url}")

def ema(a, length):
    a = np.asarray(a, dtype=float)
    if len(a) == 0: return np.array([])
    alpha = 2.0/(length+1.0)
    out = np.empty_like(a); out[:] = np.nan
    out[0] = a[0]
    for i in range(1, len(a)): out[i] = alpha*a[i] + (1-alpha)*out[i-1]
    return out

def rma(x, length):
    x = np.asarray(x, dtype=float)
    out = np.full_like(x, np.nan)
    if len(x) < length: return out
    out[length-1] = np.mean(x[:length])
    for i in range(length, len(x)):
        out[i] = (out[i-1]*(length-1) + x[i]) / length
    return out

def supertrend(h, l, c, period=18, mult=1.5):
    h = np.asarray(h, dtype=float); l = np.asarray(l, dtype=float); c = np.asarray(c, dtype=float)
    n = len(c)
    if n == 0: return np.array([]), np.array([])
    prev_close = np.concatenate(([c[0]], c[:-1]))
    tr = np.maximum.reduce([h - l, np.abs(h - prev_close), np.abs(l - prev_close)])
    atr = rma(tr, period)
    hl2 = (h + l) / 2.0
    upper = hl2 + mult*atr; lower = hl2 - mult*atr
    fub = np.copy(upper); flb = np.copy(lower)
    for i in range(1, n):
        fub[i] = upper[i] if (upper[i] < fub[i-1]) or (c[i-1] > fub[i-1]) else fub[i-1]
        flb[i] = lower[i] if (lower[i] > flb[i-1]) or (c[i-1] < flb[i-1]) else flb[i-1]
    trend = np.ones(n, dtype=int); st = np.full(n, np.nan)
    trend[0] = 1; st[0] = flb[0]
    for i in range(1, n):
        if trend[i-1] == 1:
            if c[i] <= fub[i]: trend[i] = -1; st[i] = fub[i]
            else:              trend[i] =  1; st[i] = flb[i]
        else:
            if c[i] >= flb[i]: trend[i] =  1; st[i] = flb[i]
            else:              trend[i] = -1; st[i] = fub[i]
    return st, trend

def macd(c, fast=12, slow=26, signal=9):
    c = np.asarray(c, dtype=float)
    m = ema(c, fast) - ema(c, slow)
    s = ema(m, signal)
    h = m - s
    return m, s, h

def adx(h, l, c, length=14):
    h = np.asarray(h, dtype=float); l = np.asarray(l, dtype=float); c = np.asarray(c, dtype=float)
    if len(c) < length+2: return np.full(len(c), np.nan)
    up = h[1:] - h[:-1]
    dn = l[:-1] - l[1:]
    plusDM = np.where((up > dn) & (up > 0), up, 0.0)
    minusDM = np.where((dn > up) & (dn > 0), dn, 0.0)
    prev_close = c[:-1]
    tr = np.maximum.reduce([h[1:] - l[1:], np.abs(h[1:] - prev_close), np.abs(l[1:] - prev_close)])
    atr = rma(tr, length)
    pDI = 100 * rma(plusDM, length) / atr
    mDI = 100 * rma(minusDM, length) / atr
    dx = 100 * np.abs(pDI - mDI) / (pDI + mDI)
    adxv = rma(dx, length)
    adxv = np.concatenate(([np.nan], adxv))
    return adxv

def norm01(x, lo, hi):
    if x is None or np.isnan(x): return 0.0
    if hi == lo: return 0.0
    return float(max(0.0, min(1.0, (x - lo)/(hi - lo))))

def tv_link(sym): return f"https://www.tradingview.com/chart/?symbol={TV_PREFIX}:{sym.replace('-', '')}&interval={INTERVAL_MIN}"

# OKX
def okx_top_usdt(top_n=100):
    j = get_json("https://www.okx.com/api/v5/market/tickers", params={"instType":"SPOT"})
    arr = j.get("data") or []
    rows = []
    for d in arr:
        inst = d.get("instId","")
        if not inst.endswith("-USDT"): continue
        if any(x in inst for x in ["3L","3S","5L","5S","2L","2S"]): continue
        qv = float(d.get("volCcy24h") or 0.0)
        last = float(d.get("last") or 0.0)
        if last < MIN_PRICE or qv < MIN_QVOL: continue
        rows.append((inst, qv))
    rows.sort(key=lambda x: x[1], reverse=True)
    syms = [s for s,_ in rows[:top_n]]
    qmap = {s:q for s,q in rows}
    log("OKX top:", syms[:10], "‚Ä¶", len(syms))
    return syms, qmap

def okx_klines(inst, bar="30m", limit=300):
    j = get_json("https://www.okx.com/api/v5/market/candles", params={"instId":inst, "bar":bar, "limit":limit})
    arr = j.get("data") or []
    df = pd.DataFrame(arr, columns=["ts","open","high","low","close","vol","volCcy","volQuote"])
    if df.empty: return df
    for c in ["open","high","low","close","vol"]:
        df[c] = df[c].astype(float)
    df["open_time_dt"] = pd.to_datetime(df["ts"].astype(np.int64), unit="ms", utc=True)
    df = df.sort_values("open_time_dt").reset_index(drop=True)
    return df

def okx_depth(inst, sz=20):
    j = get_json("https://www.okx.com/api/v5/market/books", params={"instId":inst, "sz":sz})
    data = (j.get("data") or [])
    if not data: return None
    dd = data[0]
    bids = dd.get("bids") or []
    asks = dd.get("asks") or []
    def qsum(levels):
        s = 0.0
        for p,q,_ in levels:
            s += float(p)*float(q)
        return s
    bq = qsum(bids); aq = qsum(asks)
    if bq+aq == 0: return None
    return (bq - aq) / (bq + aq)

def okx_swap_metrics(inst_spot):
    base = inst_spot.split("-")[0]
    inst = f"{base}-USDT-SWAP"
    oi = None; fund = None
    try:
        j1 = get_json("https://www.okx.com/api/v5/public/open-interest", params={"instType":"SWAP", "instId":inst})
        d1 = (j1.get("data") or [])
        if d1: oi = float(d1[0].get("oi") or 0.0)
    except Exception: pass
    try:
        j2 = get_json("https://www.okx.com/api/v5/public/funding-rate", params={"instId":inst})
        d2 = (j2.get("data") or [])
        if d2: fund = float(d2[0].get("fundingRate") or 0.0)
    except Exception: pass
    return oi, fund

# Bybit
def bybit_top_usdt(top_n=100):
    j = get_json("https://api.bybit.com/v5/market/tickers", params={"category":"spot"})
    arr = (j.get("result") or {}).get("list") or []
    rows = []
    for d in arr:
        sym = d.get("symbol","")
        if not sym.endswith("USDT"): continue
        if sym.endswith(("3LUSDT","3SUSDT","5LUSDT","5SUSDT","2LUSDT","2SUSDT")): continue
        qv = float(d.get("turnover24h") or 0.0)
        last = float(d.get("lastPrice") or 0.0)
        if last < MIN_PRICE or qv < MIN_QVOL: continue
        rows.append((sym, qv))
    rows.sort(key=lambda x: x[1], reverse=True)
    syms = [s for s,_ in rows[:top_n]]
    qmap = {s:q for s,q in rows}
    log("Bybit top:", syms[:10], "‚Ä¶", len(syms))
    return syms, qmap

def bybit_klines(symbol, minutes=30, limit=300):
    interval = str(minutes)
    j = get_json("https://api.bybit.com/v5/market/kline", params={"category":"spot","symbol":symbol,"interval":interval,"limit":limit})
    arr = ((j.get("result") or {}).get("list") or [])
    df = pd.DataFrame(arr, columns=["start","open","high","low","close","volume","turnover"])
    if df.empty: return df
    for c in ["open","high","low","close","volume"]: df[c] = df[c].astype(float)
    df["open_time_dt"] = pd.to_datetime(df["start"].astype(np.int64), unit="ms", utc=True)
    df = df.sort_values("open_time_dt").reset_index(drop=True)
    return df

def bybit_depth(symbol, limit=50):
    j = get_json("https://api.bybit.com/v5/market/orderbook", params={"category":"spot","symbol":symbol,"limit":limit})
    d = (j.get("result") or {})
    bids = d.get("b") or []; asks = d.get("a") or []
    def qsum(levels):
        s = 0.0
        for p,q in levels:
            s += float(p)*float(q)
        return s
    bq = qsum(bids); aq = qsum(asks)
    if bq+aq == 0: return None
    return (bq - aq)/(bq + aq)

def bybit_linear_metrics(symbol_spot):
    oi = None; fund = None
    try:
        j = get_json("https://api.bybit.com/v5/market/tickers", params={"category":"linear","symbol":symbol_spot})
        arr = (j.get("result") or {}).get("list") or []
        if arr:
            d = arr[0]
            oi = float(d.get("openInterest") or 0.0)
            fund = float(d.get("fundingRate") or 0.0)
    except Exception: pass
    return oi, fund

def news_score(base):
    token = os.environ.get("CRYPTOPANIC_TOKEN","").strip()
    if not token: return None
    try:
        j = get_json("https://cryptopanic.com/api/v1/posts/", params={
            "auth_token": token,
            "currencies": base,
            "kind": "news",
            "filter": "rising",
            "public": "true",
        })
        results = j.get("results") or []
        pos = neg = 0
        for r in results[:20]:
            votes = r.get("votes") or {}
            pos += int(votes.get("positive",0)); neg += int(votes.get("negative",0))
        if pos+neg == 0: return 0.0
        score = (pos - neg) / max(1, pos + neg)
        return max(0.0, min(1.0, 0.5 + 0.5*score))
    except Exception:
        return None

STATE_FILE = "last_bar_30m.txt"
def read_last_bar_ts():
    try:
        return int(open(STATE_FILE,"r").read().strip())
    except Exception:
        return None
def write_last_bar_ts(ts):
    try:
        with open(STATE_FILE,"w") as f: f.write(str(ts))
    except Exception as e:
        log("state write err:", e)

def scan_symbol(sym, qmap):
    if SRC == "okx":
        df = okx_klines(sym, bar=f"{INTERVAL_MIN}m", limit=400)
    else:
        df = bybit_klines(sym, minutes=INTERVAL_MIN, limit=400)
    if df is None or df.empty or len(df) < 120: return None

    i = len(df) - 2
    close = df["close"].values; high = df["high"].values; low = df["low"].values; vol = df["volume"].values

    st, tr = supertrend(high, low, close, 18, 1.5)
    m, s, _ = macd(close, 12, 26, 9)
    adx30   = adx(high, low, close, 14)

    st_buy  = (tr[i] == 1 and tr[i-1] == -1)
    st_sell = (tr[i] == -1 and tr[i-1] == 1)
    macd_up = (m[i-1] <= s[i-1]) and (m[i] > s[i])
    macd_dn = (m[i-1] >= s[i-1]) and (m[i] < s[i])

    if not ((st_buy and macd_up) or (st_sell and macd_dn)):
        return None

    rv = np.nan
    if i >= 21:
        avg20 = np.mean(vol[i-20:i])
        rv = vol[i] / avg20 if avg20 > 0 else np.nan

    hh = np.max(close[max(0, i-55):i+1]); ll = np.min(close[max(0, i-55):i+1])
    if st_buy:
        bo = 1.0 - max(0.0, (hh - close[i]) / (0.01 * close[i]))
    else:
        bo = 1.0 - max(0.0, (close[i] - ll) / (0.01 * close[i]))
    bo = max(0.0, min(1.0, bo))

    rng = max(1e-12, high[i] - low[i])
    near_high = (close[i] - low[i]) / rng
    near_low  = (high[i] - close[i]) / rng
    cndl = near_high if st_buy else near_low
    cndl = max(0.0, min(1.0, cndl))

    if SRC == "okx":
        df4 = okx_klines(sym, bar="4H", limit=300)
    else:
        df4 = bybit_klines(sym, minutes=240, limit=300)
    c4 = df4["close"].values if not df4.empty else np.array([])
    mtf = False
    if len(c4) >= 200:
        ema50 = ema(c4, 50); ema200 = ema(c4, 200)
        m4, s4, h4 = macd(c4, 12, 26, 9)
        j = len(c4) - 1
        if st_buy:
            mtf = (c4[j] > ema50[j] > ema200[j]) and (h4[j] > 0)
        else:
            mtf = (c4[j] < ema50[j] < ema200[j]) and (h4[j] < 0)

    try:
        ob_imb = okx_depth(sym, 20) if SRC=="okx" else bybit_depth(sym, 50)
    except Exception:
        ob_imb = None
    if ob_imb is None:
        ob_sig = 0.5
    else:
        ob_sig = ob_imb if st_buy else -ob_imb
        ob_sig = max(-1.0, min(1.0, ob_sig))
        ob_sig = 0.5 + 0.5*ob_sig

    oi = None; fund = None
    try:
        oi, fund = (okx_swap_metrics(sym) if SRC=="okx" else bybit_linear_metrics(sym.replace("-", "")))
    except Exception:
        pass

    bar_close_ms = int(df.iloc[i]["open_time_dt"].value/1e6) if "open_time_dt" in df else 0

    return {
        "symbol": sym,
        "side": "BUY" if st_buy else "SELL",
        "price": float(close[i]),
        "rvol": float(rv) if rv==rv else None,
        "adx":  float(adx30[i]) if adx30[i]==adx30[i] else None,
        "bo":   bo,
        "cndl": cndl,
        "mtf":  bool(mtf),
        "ob":   float(ob_sig) if ob_sig is not None else 0.5,
        "qvol": float(qmap.get(sym, 0.0)),
        "oi":   oi,
        "fund": fund,
        "bar_close_ms": bar_close_ms,
    }

def news_score(base):
    token = os.environ.get("CRYPTOPANIC_TOKEN","").strip()
    if not token: return None
    try:
        j = get_json("https://cryptopanic.com/api/v1/posts/", params={
            "auth_token": token,
            "currencies": base,
            "kind": "news",
            "filter": "rising",
            "public": "true",
        })
        results = j.get("results") or []
        pos = neg = 0
        for r in results[:20]:
            votes = r.get("votes") or {}
            pos += int(votes.get("positive",0)); neg += int(votes.get("negative",0))
        if pos+neg == 0: return 0.0
        score = (pos - neg) / max(1, pos + neg)
        return max(0.0, min(1.0, 0.5 + 0.5*score))
    except Exception:
        return None

def norm01(x, lo, hi):
    if x is None or np.isnan(x): return 0.0
    if hi == lo: return 0.0
    return float(max(0.0, min(1.0, (x - lo)/(hi - lo))))

def add_news_and_score(rows):
    oi_vals = [r["oi"] for r in rows if r.get("oi") is not None and r.get("oi")==r.get("oi")]
    oi_min = min(oi_vals) if oi_vals else 0.0
    oi_max = max(oi_vals) if oi_vals else 1.0
    out = []
    for r in rows:
        base = r["symbol"].split("-")[0] if SRC=="okx" else r["symbol"].replace("USDT","")
        nscore = news_score(base)

        rv_n   = norm01(r.get("rvol"), 1.0, 3.0)
        adx_n  = norm01(r.get("adx"),  15.0, 35.0)
        mtf_n  = 1.0 if r.get("mtf") else 0.0
        bo_n   = r.get("bo") or 0.0
        cndl_n = r.get("cndl") or 0.0
        ob_n   = r.get("ob") or 0.5
        oi_raw = r.get("oi")
        oi_n   = 0.0
        if oi_vals:
            oi_n = norm01(oi_raw if oi_raw is not None else oi_min, oi_min, oi_max)

        fund = r.get("fund")
        fund_n = 0.5
        if fund is not None:
            if r["side"] == "BUY":
                fund_n = max(0.0, min(1.0, 0.5 + (-min(fund, 0.01))/0.02))
            else:
                fund_n = max(0.0, min(1.0, 0.5 + (min(max(fund,0.0),0.01))/0.02))

        news_n = nscore if nscore is not None else 0.5

        score = 100.0 * (
            0.25*rv_n + 0.20*adx_n + 0.20*mtf_n + 0.10*bo_n +
            0.05*cndl_n + 0.10*ob_n + 0.05*oi_n + 0.05*fund_n
        )
        score += 5.0 * (news_n - 0.5)
        r["score"] = float(score)
        r["news"]  = None if nscore is None else float(nscore)
        out.append(r)
    return out

def send_tg(text):
    tok = os.environ.get("CRYPTO_TELEGRAM_BOT_TOKEN","").strip()
    chat= os.environ.get("CRYPTO_TELEGRAM_CHAT_ID","").strip()
    if not tok or not chat:
        log("Missing Telegram creds"); return
    try:
        r = S.post(f"https://api.telegram.org/bot{tok}/sendMessage",
                   data={"chat_id": chat, "text": text[:3900], "parse_mode":"HTML","disable_web_page_preview":True},
                   timeout=TIMEOUT)
        log("TG:", r.status_code, (r.text or "")[:160])
    except Exception as e:
        log("TG error:", e)

def main():
    send_tg(f"‚è±Ô∏è Crypto 30m ST+MACD scan start ‚Äî src={SRC.upper()}")
    if SRC == "okx":
        syms, qmap = okx_top_usdt(TOP_N)
    else:
        syms, qmap = bybit_top_usdt(TOP_N)

    raw = []; last_bar = None
    for s in syms:
        try:
            r = scan_symbol(s, qmap)
            if r:
                raw.append(r); last_bar = r["bar_close_ms"]
        except Exception as e:
            log("scan err", s, e)
        time.sleep(THROTTLE)

    if not raw:
        send_tg("‚úîÔ∏è No ST+MACD same-candle signals on 30m.")
        return

    prev = read_last_bar_ts()
    if last_bar is not None and prev is not None and prev == last_bar:
        log("Duplicate bar; skipping send.")
        return

    rows = add_news_and_score(raw)
    rows.sort(key=lambda x: x.get("score", 0.0), reverse=True)
    top10 = rows[:10]

    ultra = []
    for r in rows:
        if r.get("rvol") is None or r.get("adx") is None: continue
        cond = (r["rvol"] >= ULTRA_MIN_RVOL) and (r["adx"] >= ULTRA_MIN_ADX) and r["mtf"]
        if r["side"] == "BUY":
            cond = cond and (r["bo"] >= (1.0 - ULTRA_BO_TOL)) and (r["ob"] >= ULTRA_OB_MIN)
        else:
            cond = cond and (r["bo"] >= (1.0 - ULTRA_BO_TOL)) and (r["ob"] <= (1.0 - ULTRA_OB_MIN))
        if cond:
            ultra.append(r)
    ultra.sort(key=lambda x: x["score"], reverse=True)
    ultra2 = ultra[:2]

    ts = dt.datetime.utcnow().strftime("%d-%b %H:%M UTC")
    lines = [f"<b>Crypto ST+MACD 30m</b> ‚Äî {html.escape(ts)} ‚Äî {SRC.upper()} Top {TOP_N}"]
    if ultra2:
        lines.append("üî• <b>Ultra Top 2</b>")
        for r in ultra2:
            rv = "NA" if r.get("rvol") is None else f"{r['rvol']:.2f}x"
            ad = "NA" if r.get("adx") is None else f"{r['adx']:.1f}"
            ob = f"{r['ob']:.2f}"
            nf = "-" if r.get("news") is None else f"{r['news']:.2f}"
            lines.append(f"‚Ä¢ {r['side']} <b>{r['symbol']}</b> @ {r['price']:.6f} | S:{r['score']:.1f} | RV:{rv} | ADX:{ad} | OB:{ob} | News:{nf} | <a href='{tv_link(r['symbol'])}'>TV</a>")
    if top10:
        lines.append("üèÜ <b>Top 10 Strong</b>")
        for r in top10:
            rv = "NA" if r.get("rvol") is None else f"{r['rvol']:.2f}x"
            ad = "NA" if r.get("adx") is None else f"{r['adx']:.1f}"
            ob = f"{r['ob']:.2f}"
            nf = "-" if r.get("news") is None else f"{r['news']:.2f}"
            lines.append(f"‚Ä¢ {r['side']} <b>{r['symbol']}</b> @ {r['price']:.6f} | S:{r['score']:.1f} | RV:{rv} | ADX:{ad} | OB:{ob} | News:{nf} | <a href='{tv_link(r['symbol'])}'>TV</a>")

    send_tg("\n".join(lines))
    if last_bar is not None:
        write_last_bar_ts(last_bar)
    log("Sent.")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        tb = traceback.format_exc()
        log("Fatal:", e); print(tb)
        try:
            send_tg(f"‚ö†Ô∏è Crypto bot error:\n<pre>{html.escape(tb[-3000:])}</pre>")
        except Exception: pass
        sys.exit(0)
PY

      - name: Syntax check
        run: python -m py_compile runner_bot.py

      - name: Run scanner
        env:
          EX_SOURCE: okx           # bybit karna ho to yahan bybit likho
          CRYPTO_TELEGRAM_BOT_TOKEN: ${{ secrets.CRYPTO_TELEGRAM_BOT_TOKEN }}
          CRYPTO_TELEGRAM_CHAT_ID: ${{ secrets.CRYPTO_TELEGRAM_CHAT_ID }}
          CRYPTOPANIC_TOKEN: ${{ secrets.CRYPTOPANIC_TOKEN }}
        run: python runner_bot.py
